using Microsoft.Diagnostics.Tracing;
using Microsoft.Diagnostics.Tracing.Parsers.Clr;

namespace Detector2;

public class EventPipeTypeResolver
{
    private readonly List<ParserMethod> _methods = new();
    private readonly ParserMethod _lookupParserMethod = new("", default, default);
    private readonly Dictionary<ulong, string> _typeNames = new();

    public EventPipeTypeResolver(EventPipeEventSource eventSource)
    {
        eventSource.Clr.MethodLoadVerbose += OnMethodLoadVerbose;
        eventSource.Clr.MethodDCStartVerboseV2 += OnMethodLoadVerbose;
        eventSource.Clr.MethodDCStopVerboseV2 += OnMethodLoadVerbose;
        eventSource.Clr.TypeBulkType += OnTypeBulkType;

        var rundownParser = new ClrRundownTraceEventParser(eventSource);
        rundownParser.MethodDCStartVerbose += OnMethodLoadVerbose;
        rundownParser.MethodDCStopVerbose += OnMethodLoadVerbose;
    }

    /// <remarks>
    /// Most of the addresses are resolved from type unload events generated by the rundown provider.
    /// So resolving call stacks before the end of the processing will probably call stack with
    /// missing method names.
    /// </remarks>
    public EventPipeResolveStack ResolveCallStack(EventPipeUnresolvedStack stack)
    {
        var addresses = new EventPipeResolvedAddress[stack.Addresses.Length];

        for (var index = 0; index < addresses.Length; index++)
        {
            var address = stack.Addresses[index];
            addresses[index] = new EventPipeResolvedAddress(address, GetMethodFullName(address));
        }

        return new EventPipeResolveStack(addresses);
    }

    public string? GetTypeName(ulong typeId)
    {
        return _typeNames.GetValueOrDefault(typeId);
    }

    private void OnTypeBulkType(GCBulkTypeTraceData traceData)
    {
        for (var index = 0; index < traceData.Count; index++)
        {
            var typeData = traceData.Values(index);
            _typeNames[typeData.TypeID] = typeData.TypeName;
        }
    }

    public string? GetMethodFullName(ulong address)
    {
        var index = SearchMethodIndex(address);
        if (index >= 0)
            return _methods[index].FullName;

        var previousIndex = (~index) - 1;
        if (previousIndex >= 0 && _methods[previousIndex].ContainsAddress(address))
            return _methods[previousIndex].FullName;

        return null;
    }

    private void OnMethodLoadVerbose(MethodLoadUnloadVerboseTraceData traceData)
    {
        var index = SearchMethodIndex(traceData.MethodStartAddress);
        if (index >= 0)
            return;

        var insertIndex = ~index;
        var fullName = GetFullName(traceData);
        var parserMethod = new ParserMethod(fullName,traceData.MethodStartAddress, (uint)traceData.MethodSize);
        _methods.Insert(insertIndex, parserMethod);
    }

    private int SearchMethodIndex(ulong address)
    {
        _lookupParserMethod.StartAddress = address;

        return _methods.BinarySearch(_lookupParserMethod, ParserMethodAddressComparer.Instance);
    }

    private static string GetFullName(MethodLoadUnloadVerboseTraceData data)
    {
        var sig = data.MethodSignature;
        var parens = sig.IndexOf('(');
        var args = parens >= 0 ? sig.Substring(parens) : "";

        return data.MethodNamespace + "." + data.MethodName + args;
    }

    private class ParserMethod
    {
        public ParserMethod(string fullName, ulong startAddress, uint length)
        {
            FullName = fullName;
            StartAddress = startAddress;
            Length = length;
        }

        public string FullName;
        public ulong StartAddress;
        public uint Length;

        public bool ContainsAddress(ulong address)
        {
            return address >= StartAddress && address < (StartAddress + Length);
        }
    }

    private class ParserMethodAddressComparer : IComparer<ParserMethod>
    {
        public static ParserMethodAddressComparer Instance { get; } = new();
        public int Compare(ParserMethod? x, ParserMethod? y)
        {
            return x!.StartAddress.CompareTo(y!.StartAddress);
        }
    }
}
