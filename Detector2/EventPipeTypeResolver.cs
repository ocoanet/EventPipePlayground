using Microsoft.Diagnostics.Tracing;
using Microsoft.Diagnostics.Tracing.Parsers.Clr;

namespace Detector2;

public class EventPipeTypeResolver
{
    private readonly List<MethodDescriptor> _methods = new();
    private readonly MethodDescriptor _lookupParserMethod = new("", default, default);
    private readonly Dictionary<ulong, string> _typeNames = new();

    public EventPipeTypeResolver(EventPipeEventSource eventSource)
    {
        eventSource.Clr.MethodLoadVerbose += OnMethodLoadVerbose;
        eventSource.Clr.MethodDCStartVerboseV2 += OnMethodLoadVerbose;
        eventSource.Clr.MethodDCStopVerboseV2 += OnMethodLoadVerbose;
        eventSource.Clr.TypeBulkType += OnTypeBulkType;

        var rundownParser = new ClrRundownTraceEventParser(eventSource);
        rundownParser.MethodDCStartVerbose += OnMethodLoadVerbose;
        rundownParser.MethodDCStopVerbose += OnMethodLoadVerbose;
    }

    /// <remarks>
    /// Most of the addresses are resolved from type unload events generated by the rundown provider.
    /// So resolving call stacks before the end of the processing will probably call stack with
    /// missing method names.
    /// </remarks>
    public EventPipeResolvedStack ResolveCallStack(EventPipeUnresolvedStack stack)
    {
        var addresses = new EventPipeResolvedAddress[stack.Addresses.Length];

        for (var index = 0; index < addresses.Length; index++)
        {
            var address = stack.Addresses[index];
            addresses[index] = new EventPipeResolvedAddress(address, GetMethodFullName(address));
        }

        return new EventPipeResolvedStack(addresses);
    }

    public string? GetTypeName(ulong typeId)
    {
        return _typeNames.GetValueOrDefault(typeId);
    }

    private void OnTypeBulkType(GCBulkTypeTraceData traceData)
    {
        for (var index = 0; index < traceData.Count; index++)
        {
            var typeData = traceData.Values(index);
            _typeNames[typeData.TypeID] = typeData.TypeName;
        }
    }

    public string? GetMethodFullName(ulong address)
    {
        var index = SearchMethodIndex(address);
        if (index >= 0)
            return _methods[index].FullName;

        var previousIndex = (~index) - 1;
        if (previousIndex >= 0 && _methods[previousIndex].ContainsAddress(address))
            return _methods[previousIndex].FullName;

        return null;
    }

    private void OnMethodLoadVerbose(MethodLoadUnloadVerboseTraceData traceData)
    {
        var methodStartAddress = traceData.MethodStartAddress;
        var index = SearchMethodIndex(methodStartAddress);
        if (index >= 0)
            return;

        var insertIndex = ~index;
        var fullName = GetFullName(traceData);
        var methodSize = (uint)traceData.MethodSize;
        var parserMethod = new MethodDescriptor(fullName, methodStartAddress, methodSize);
        _methods.Insert(insertIndex, parserMethod);
    }

    private int SearchMethodIndex(ulong address)
    {
        _lookupParserMethod.StartAddress = address;

        return _methods.BinarySearch(_lookupParserMethod, MethodDescriptorAddressComparer.Instance);
    }

    private static string GetFullName(MethodLoadUnloadVerboseTraceData data)
    {
        var sig = data.MethodSignature;
        var parens = sig.IndexOf('(');
        var args = parens >= 0 ? sig.Substring(parens) : "";

        return data.MethodNamespace + "." + data.MethodName + args;
    }

    private class MethodDescriptor
    {
        public MethodDescriptor(string fullName, ulong startAddress, uint length)
        {
            FullName = fullName;
            StartAddress = startAddress;
            Length = length;
        }

        public string FullName;
        public ulong StartAddress;
        public uint Length;

        public bool ContainsAddress(ulong address)
        {
            return address >= StartAddress && address < (StartAddress + Length);
        }
    }

    private class MethodDescriptorAddressComparer : IComparer<MethodDescriptor>
    {
        public static MethodDescriptorAddressComparer Instance { get; } = new();

        public int Compare(MethodDescriptor? x, MethodDescriptor? y)
        {
            return x!.StartAddress.CompareTo(y!.StartAddress);
        }
    }
}
